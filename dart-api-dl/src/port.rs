use std::{ffi::CString, mem::forget, ops::Deref};

use dart_api_dl_sys::{
    Dart_CObject, Dart_CloseNativePort_DL, Dart_NewNativePort_DL, Dart_PostCObject_DL,
    Dart_PostInteger_DL, ILLEGAL_PORT,
};

use thiserror::Error;

use crate::{
    cobject::{CObjectType, ExternCObject, OwnedCObject},
    lifecycle::DartRuntime,
    panic::catch_unwind_panic_as_cobject,
    slot::fpslot,
};

/// Raw Id of a dart Port.
///
/// Same as `Dart_Port_DL`.
///
// We redefine this as using `cbindgen` with a exported
// type generated by `bindgen` doesn't work. At the same
// time as `dart_api_dl.h` isn't cleanly separated from
// other dart api's we don't want to `include` it into
// the file generated by `bindgen`. There is also the
// problem was in same places `Dart_Port` is used due to
// the non-clear separation.
pub type DartPortId = i64;

// like Dart_NativeMessageHandler_DL but not wrapped in an `Option`
type DartNativeMessageHandler =
    unsafe extern "C" fn(dest_port_id: DartPortId, message: *mut Dart_CObject);

impl DartRuntime {
    /// Wraps the port.
    ///
    /// Returns `None` if `port == ILLEGAL_PORT`.
    /// This is done so because `ILLEGAL_PORT` is in generally
    /// used to indicate both "no port" and "somehow bad port".
    ///
    pub fn send_port_from_raw(&self, port: DartPortId) -> Option<SendPort> {
        self.send_port_from_raw_with_origin(port, ILLEGAL_PORT)
    }

    /// Wraps the port.
    ///
    /// Returns `None` if `port == ILLEGAL_PORT`.
    /// This is done so because `ILLEGAL_PORT` is in generally
    /// used to indicate both "no port" and "somehow bad port".
    ///
    /// `origin_id` is set when creating a send port in dart to
    /// the "default" port of the isolate the send port was created
    /// in, but can be unset.
    ///
    /// Which means it's nearly always `ILLEGAL_PORT` for usages of this
    /// function as it can be called outside of a dart isolate, and
    /// because we have no way to access the port of a isolate we
    /// might happen to be in.
    ///
    pub fn send_port_from_raw_with_origin(
        &self,
        port: DartPortId,
        origin: DartPortId,
    ) -> Option<SendPort> {
        (port != ILLEGAL_PORT).then(|| SendPort { port, origin })
    }

    /// Wrap a port id as `NativeRecvPort`.
    ///
    /// This closed the port when this wrapper is dropped.
    pub fn native_recv_port_from_raw(&self, port: DartPortId) -> Option<NativeRecvPort> {
        (port != ILLEGAL_PORT).then(|| {
            NativeRecvPort(SendPort {
                port,
                origin: ILLEGAL_PORT,
            })
        })
    }

    /// Creates a new [`NativeRecvPort`].
    ///
    /// # Safety
    ///
    /// The `handler` muss be safe to use under given `handle_concurrently` option.
    ///
    unsafe fn unsafe_native_recp_port(
        &self,
        name: &str,
        handler: DartNativeMessageHandler,
        handle_concurrently: bool,
    ) -> Option<NativeRecvPort> {
        let c_name = CString::new(name).ok()?;

        let port = fpslot!(@call Dart_NewNativePort_DL(c_name.as_ptr(), Some(handler), handle_concurrently));

        self.native_recv_port_from_raw(port)
    }

    /// A rust-safe way to creates a new [`NativeRecvPort`].
    pub fn native_recv_port<N>(&self) -> Option<NativeRecvPort>
    where
        N: NativeMessageHandler,
    {
        //SAFE: The handle_message wrapper provides a safe abstraction
        return unsafe {
            self.unsafe_native_recp_port(N::NAME, handle_message::<N>, N::CONCURRENT_HANDLING)
        };

        unsafe extern "C" fn handle_message<N>(ourself: DartPortId, data_ref: *mut Dart_CObject)
        where
            N: NativeMessageHandler,
        {
            if let Ok(rt) = DartRuntime::instance() {
                if let Some(port) = rt.native_recv_port_from_raw(ourself) {
                    //TODO catch_unwind
                    ExternCObject::with_pointer(data_ref, |data| {
                        catch_unwind_panic_as_cobject(
                            data,
                            |data| N::handle_message(rt, &port, data),
                            |data, panic_obj| N::handle_panic(rt, &port, data, panic_obj),
                        );
                    });
                    forget(port);
                }
            }
        }
    }
}

/// Static rust-safe version of `Dart_NativeMessageHandler_DL`.
pub trait NativeMessageHandler {
    const CONCURRENT_HANDLING: bool;
    const NAME: &'static str;
    fn handle_message(rt: DartRuntime, ourself: &NativeRecvPort, data: &mut ExternCObject);
    fn handle_panic(
        rt: DartRuntime,
        ourself: &NativeRecvPort,
        data: &mut ExternCObject,
        panic: &mut OwnedCObject,
    );
}

/// Represents a "NativeSendPort" which can be used to send messages to dart.
///
/// # Safety
///
/// Many of the APIs are safe but this relies on following assumptions:
///
/// - The underlying `Dart_CObject` is safe, we make sure it is if only
///   safe code was used.
///
///
#[derive(Debug, Clone, Copy)]
pub struct SendPort {
    port: DartPortId,
    // Not sure what it is used for. In nearly all
    // cases this is equal to `ILLEGAL_PORT` and you
    // always can set it to `ILLEGAL_PORT`.
    origin: DartPortId,
}

impl SendPort {
    pub fn as_raw(&self) -> (DartPortId, DartPortId) {
        (self.port, self.origin)
    }

    /// Sends given integer to given port.
    ///
    pub fn post_integer(&self, message: i64) -> Result<(), PortPostMessageFailed> {
        // SAFE: As long as trying to send to a closed port is safe, which should be
        //       safe for darts security model to work.
        if unsafe { fpslot!(@call Dart_PostInteger_DL(self.port, message)) } {
            Ok(())
        } else {
            Err(PortPostMessageFailed)
        }
    }

    /// See: [`SendPort.post_cobject_mut()`].
    pub fn post_cobject(&self, mut cobject: OwnedCObject) -> Result<(), PortPostMessageFailed> {
        self.post_cobject_mut(&mut cobject)
    }

    /// Sends given [`ExternalCObject`] to given port.
    ///
    /// Like normally for data which is not externally typed a copy of the data is send
    /// over the port and the object stays unchanged (through it might get temp.
    /// modified while being enqueued, which isn't a problem for us to to the
    /// guarantees of `&mut`).
    ///
    /// In case of external typed data it will get send to the client, to avoid
    /// problem and allow auto dropping not send external typed data we set the
    /// type of the [`ExternalCObject`] to `null`.
    ///
    /// If sending fails the external typed data is still be in the [`ExternalCObject`]
    /// and can be reused.
    ///
    pub fn post_cobject_mut(
        &self,
        cobject: &mut ExternCObject,
    ) -> Result<(), PortPostMessageFailed> {
        let need_nulling = cobject.r#type() == Ok(CObjectType::ExternalTypedData);
        // SAFE: As long as `OwnedCObject` was properly constructed and is kept in a sound
        //       sate which is a requirements of it's unsafe interfaces.
        if unsafe { fpslot!(@call Dart_PostCObject_DL(self.port, cobject.as_ptr_mut())) } {
            if need_nulling {
                cobject.set_to_null();
            }
            Ok(())
        } else {
            Err(PortPostMessageFailed)
        }
    }

    //TODO post_slice(&mut [&mut ExternalCObject]) which doesn't allocate a vec or box the objects
}

/// Handler for a native receiver port.
///
/// If this handler is dropped the port is closed.
#[derive(Debug)]
pub struct NativeRecvPort(SendPort);

impl NativeRecvPort {
    /// Prevent drop form closing this type.
    pub fn leak(self) -> SendPort {
        let port = *self;
        forget(self);
        port
    }
}

impl Drop for NativeRecvPort {
    fn drop(&mut self) {
        // SAFE:
        // - Is save is calling dart functions is safe
        // - and if calling it a bad port id is safe
        //
        // Both should be the case
        unsafe { fpslot!(@call Dart_CloseNativePort_DL(self.as_raw().0)) };
    }
}

impl Deref for NativeRecvPort {
    type Target = SendPort;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

#[derive(Debug, Error)]
#[error("Posting message failed.")]
pub struct PortPostMessageFailed;

#[cfg(test)]
mod tests {
    use dart_api_dl_sys::{Dart_NativeMessageHandler_DL, Dart_Port_DL};
    use static_assertions::{assert_impl_all, assert_type_eq_all};

    use super::*;

    #[test]
    fn test_static_assertions() {
        assert_impl_all!(SendPort: Send, Sync, Copy, Clone);
        assert_impl_all!(NativeRecvPort: Send, Sync);

        assert_type_eq_all!(Dart_Port_DL, DartPortId, i64);
        assert_type_eq_all!(
            Option<DartNativeMessageHandler>,
            Dart_NativeMessageHandler_DL
        );
    }
}
